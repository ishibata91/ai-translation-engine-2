# Design: PersonaGenSlice

## Context

現状のv1.x Python版ツールでは、話者の種族や固有の性格といったコンテキストが翻訳システムに適切に伝わっておらず、単純な種族・声ベースからの推測に依存しているため、没入感のある自然な翻訳（特に口調の一貫性）が難しい状態です。新アーキテクチャ(v2.0)への移行・VSA(Vertical Slice Architecture)の推進に伴い、AIに文脈として「NPCペルソナ（性格特性、話し方の癖、背景設定）」を事前に生成させてコンテキストとして与える必要があります。
同時に、限られたLLMコンテキストウィンドウを有効活用するため、ただ会話履歴を羅列するのではなく、事前に重要な会話群群を評価・選定からペルソナを要約生成し、キャッシュ(永続化)するアーキテクチャが必要とされています。

## Goals / Non-Goals

**Goals:**
- NPCの会話データ（最大100件）を独自定義の重要度ルールで抽出し、LLMによるペルソナ生成を行う独立した `PersonaGenSlice` を実装する。
- Consumer-Driven Contractsの原則に基づき、本スライス独自の入力DTOを定義し、他パッケージのモデルに依存させない。
- トークン長の事前計算・評価プロセスを組み込み、LLMのコンテキストオーバーエラーを未然に防止する。
- SQLiteデータベース上の `npc_personas` テーブルへのペルソナ情報の永続化（生成とUPSERT）において、すべてのDBアクセスおよびスキーマ定義ロジックをスライス内にカプセル化する。

**Non-Goals:**
- Pass 2での実際の翻訳処理（ペルソナの適用は `ContextEngineSlice` やその他の翻訳スライス側の責務とする）。
- グローバルなデータモデル（pkg/domain 等）の作成や共有。

## Decisions

1. **Consumer-Driven Contracts DTO の導入**
   - **Rationale**: オーケストレーター層から受け取るデータの型として、`PersonaGenSlice` 専用のDTO（例：`PersonaRequest` や `DialogueContext` など）を定義します。外部スライスの実装詳細による破壊的変更から保護されます。

2. **重要度スコアリングロジック (`ImportanceScorer`)**
   - **Rationale**: 最大100件の選別のため、①固有名詞の出現数（W_noun=2）と、②感情指標（W_emotion=1、!, ?, ALL CAPS、特定強意語）をカウントし、クエスト関連の優先度(base_priority)と合わせてスコアリングします。これにより特徴的な発話がLLMに渡されやすくなります。

3. **トークン利用量の事前計算 (`TokenEstimator`)**
   - **Rationale**: `文字数 / 4` 程度の簡易推定を用い、出力用固定トークン（約500）の猶予分と合わせて利用予定トークンを計算します。制限を超える場合はデータを重要度順で削減し、動的な安全確保に努めます。

4. **カプセル化された永続化層 (`PersonaStore`)**
   - **Rationale**: 外部からは `*sql.DB` の接続プールのみを受け取り、テーブル `npc_personas` の作成および保存・更新ロジックはスライス内部に閉じ込めます。

5. **定型化されたデバッグログ基盤への適合**
   - **Rationale**: `slog-otel` を用いた構造化ログ方針に基づき、処理の開始・終了時にスライス内部の各関数の引数・実行結果を `slog.DebugContext` でロギングし、`trace_id` を伝播させます。

## Risks / Trade-offs

- **LLM呼び出しコストと処理時間**
  - **Risk**: すべてのNPCに対して個別にLLMアクセスを行うと時間とAPIコストがかかります。
  - **Mitigation**: すり合わせとして、ペルソナは一度生成したら永続化しUPSERTでキャッシュ化することで、再処理時の負荷を抑えます。また設定による並行処理で実行時間を削減します。
- **SQLite の並行書き込みロック**
  - **Risk**: 複数のGoroutineから同時に生成結果をUPSERTする際、SQLite特有のデータベースロック(`database is locked`) が発生し得ます。
  - **Mitigation**: プロジェクト設定側でのWALモード(`journal_mode=WAL`)の有効化に加え、スライス側の `*sql.DB` 呼び出し設計で適切に更新できるように制限またはリトライを行います。
