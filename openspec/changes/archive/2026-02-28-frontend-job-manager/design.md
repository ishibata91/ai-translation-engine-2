# Design: frontend-job-manager

## Context
フロントエンド（React）から開始される辞書構築、マスターペルソナ抽出、翻訳プロジェクト等のタスクをバックグラウンドで管理し、UIへ進捗やリアルタイムな追加項目を通知する。
予期せぬ終了からの復帰（再開可能タスク）や、ダッシュボードからタスクの「今のフェーズ」に応じた画面へ遷移する要件が存在するため、タスク状態の永続化が必要。

## Goals / Non-Goals
**Goals:**
- タスクモデル（ID、Name、Status、Phase、Progress、Metadata等）の定義とSQLiteを使った状態の永続化。
- 予期せぬ終了時（クラッシュ等）の後、アプリ再起動時にDBの情報を読んでタスクを途中から再開（レジューム）できる仕組みの構築。
- 全体進捗の更新（`task:updated`）に加え、複数フェーズのタスクにおいて、1つのフェーズ全体が終わったタイミングで一括してフロントエンドへ通知する「フェーズ完了通知」(`task:phase_completed`) を提供する。※N+1問題を避けるため1件ごとの通知は行わない。
- ダッシュボードのタスク一覧から、当該タスクの現在の `Phase` に応じた適切な画面へ遷移させ、再開や監視を続けるUI連携。

**Non-Goals:**
- 全てのマイクロな関数レベルの再試行。再開は主に「ステップ/フェーズ」単位のチェックポイントから行う。

## Decisions
1. **Frontend TaskManager と SQLite永続化**:
   - `tasks` テーブルを作成し、タスクID、カテゴリ、現在のステータス(`Running`, `Paused`, `Completed`, `Failed`)、フェーズ、進捗、再開用パラメータ(JSON形式のメタデータ) を保存する。
   - タスク開始時にDBへレコードを作成し、フェーズ以降や進捗更新時にDBを非同期でUPDATEする。
   
2. **フェーズ完了ごとの一括データ保存と通知 (`phase_completed`)**:
   - 巨大なインポート処理や連続的な抽出処理では、1件処理するごとに `Progress` (進捗率) のみをスロットリングして emit する。
   - ループ処理内の1件ごとでのメインDB保存およびフロント通知は禁止（N+1問題の回避）。
   - タスクが新しいフェーズへ移行する（例: ペルソナ抽出フェーズが終わった）タイミングで、メモリ上で完成させた全データを一括でメインDBへ保存し、`runtime.EventsEmit("task:phase_completed", payload)` を発火する。フロントエンドはこれを契機にデータを再フェッチする。

3. **タスクのフェーズ管理と再開 (Resume)**:
   - 複数ステップ（用語抽出 → ペルソナ抽出 → 要約 → 翻訳）からなるプロジェクトにおいては、`Phase` を細かく更新・永続化する。
   - ダッシュボードから「再開（Resume）」や該当タスクをクリックした場合、フロントエンド側はその `Phase` の値を見て、適切なタブ（例：特定の翻訳プロジェクトの「ペルソナパネル」）を開いた状態でマウントさせる。

## Risks / Trade-offs
- **Risk**: 進捗や部分完了のたびにDBのUPDATEを走らせるとI/O負荷が高まる。
  **Mitigation**: %の更新のような細かい進捗のDB保存は適度にスロットリング（数秒に1回など）し、UIへの `EventsEmit` はメモリ上の値で高頻度に発火する設計とする。状態遷移（フェーズ完了時）は確実にDBロギングする。
