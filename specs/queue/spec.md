# キュー (Queue) 仕様書

## 概要
非同期タスクの実行管理、ジョブのスケジューリング、および並列処理のリミッター（スロットリング）を担うインフラストラクチャ層のコンポーネントである。当初は `job_queue` と呼ばれていたが、メッセージングや非同期ワーカー全般を扱うため `queue` に改名された。

LLMへの大量のリクエスト（特にバッチAPIや長時間待機を伴うもの）を、システム全体の負荷を考慮しながら効率的に処理するための基盤を提供する。

## 背景・動機
- **信頼性**: LLM APIのタイムアウトやRate Limitに対して、リトライやキューイングによる回復力を提供する。
- **スループットの最適化**: 複数の翻訳完了を待たずに、可能な限り並行してリクエストを発行し、リソース（API同時実行数等）を最大限活用する。
- **ユーザー体験の向上**: 長時間かかる処理をバックグラウンド化し、UIをブロックせずに進捗を通知可能にする。

## スコープ
### 本コンポーネントが担う責務
1. **ジョブの登録 (Enqueue)**: スライスから依頼されたタスク（関数実行やリクエスト送信）をキューに追加する。
2. **実行制御**: 設定された同時実行数（Concurrency）に基づき、タスクを順次実行する。
3. **リトライ管理**: 失敗したタスクを指定された回数・間隔（指数バックオフ）で再試行する。
4. **状態管理**: 待機中、実行中、成功、失敗、リトライ中などのジョブステータスを管理する。

### 本コンポーネントの責務外
- **具体的なタスクロジック**: 翻訳プロンプトの作成や結果のパースは各ドメインスライス（Translator等）が行う。
- **永続化**: ジョブ自体の永続化が必要な場合は `datastore` を利用するが、本コンポーネント自体は実行制御に集中する。

## 要件

### 1. 柔軟なバックエンド
**Reason**: 開発環境（インメモリ）と本番環境（永続キュー）でシームレスに切り替え可能にするため。

#### Scenario: インメモリワーカーの起動
- **WHEN** アプリケーション設定で `type: memory` が指定された場合
- **THEN** Goroutine を用いた並列ワーカープールを生成し、メモリ上のチャネルを介してジョブを処理する

### 2. LLMバッチAPI対応
**Reason**: xAI や Gemini のバッチ機能を抽象化し、ポーリング待機などを共通化するため。

#### Scenario: 長時間実行ジョブの監視
- **WHEN** 外部API（Batch API）のジョブIDが登録された場合
- **THEN** 定期的にステータスを確認（Polling）し、完了時に指定された保存処理（Phase 2 Save）をトリガーする

### 3. スロットリングと同時実行数制御
**Reason**: APIのRate Limit超過によるエラーを防ぎ、システム全体の安定性を保つため。

## ログ出力・テスト共通規約

> 本インフラ層は `architecture.md` セクション 6（テスト戦略）・セクション 7（構造化ログ基盤）に準拠する。

### 実装時の義務
1.  **TraceID 伝播**: ジョブの投入から実行、完了報告まで一貫した TraceID をログに保持する。
2.  **実行ログ**: ジョブごとの開始・終了・再試行回数を `slog` で詳細に記録する。
3.  **モックサポート**: テストにおいて、実際の実行を伴わずにキューイングのみを確認できるモックを提供する。
