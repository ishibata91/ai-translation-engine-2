# 設定・レイアウト保存インフラ テスト設計 (Config Test Spec)

本設計は `architecture.md` セクション 6（テスト戦略）および セクション 7（構造化ログ基盤）に厳密に準拠し、個別関数の細粒度なユニットテストを作成せず、Vertical Slice の Contract に対する網羅的なパラメタライズドテスト（Table-Driven Test）を定義する。

## 1. テスト方針

1. **細粒度ユニットテストの排除**: 内部処理や個別関数単位の振る舞いテストは作成しない。インメモリSQLite (`:memory:`) を使用し、外部に公開されている Contract (`Config`, `UIStateStore`, `SecretStore`) を通じた Slice 全体の振る舞いを検証する。
2. **網羅的パラメタライズドテスト**: すべてのテストを Table-Driven Test（表駆動テスト）として実装する。入力パラメータと期待される出力を構造体スライスで列挙し、一括で実行・検証する。
3. **構造化ログの強制検証**: テスト実行時においても、必ず `context.Context` （独自の TraceID を内包）を引き回す。スライスが正しく `slog.DebugContext(ctx, ...)` を利用し、Entry/Exit ログ（および TraceID）を出力していることを前提とした設計とする。
4. **スレッドセーフティ**: 複数 Goroutine からの同時操作をシミュレートするテストケースを用意し、`go test -race` オプションにより競合状態（データ競合やデッドロック）が発生しないことを確実に証明する。

---

## 2. パラメタライズドテストケース (Table-Driven Tests)

各Contractに対する入力（初期状態 + アクション）と期待されるアウトプット（戻り値 + 変更後の状態）を表として定義し、ループ内で検証する。

### 2.1 Config & TypedAccessor 統合テスト
バックエンド設定のプレーン文字列の保存・取得、および型変換の安全性を検証する。

| ケースID | 目的            | 初期状態 (DB)    | アクション (関数呼出)                           | 期待される結果 (戻り値 / DB状態)    |
| :------- | :-------------- | :--------------- | :---------------------------------------------- | :---------------------------------- |
| CS-01    | 基本Set/Get     | 空               | Set("llm", "prv", "gemini") → Get("llm", "prv") | "gemini" を返す                     |
| CS-02    | 上書き          | `prv="openai"`   | Set("llm", "prv", "gemini") → Get("llm", "prv") | "gemini" に更新される               |
| CS-03    | 削除            | `prv="gemini"`   | Delete("llm", "prv") → Get("llm", "prv")        | エラー（値なし）を返す              |
| CS-04    | JSON格納拒否    | 空               | Set("llm", "key", `{"a":1}`)                    | バリデーションエラーを返す          |
| CS-05    | 全件取得        | `a="1"`, `b="2"` | GetAll("llm")                                   | map形式で全エントリを返す           |
| TA-01    | Default値取得   | 空               | GetString("llm", "prv", "default")              | "default" を返す                    |
| TA-02    | Int型変換(正常) | `max="100"`      | GetInt("llm", "max", 50)                        | 100 を返す                          |
| TA-03    | Int型変換(異常) | `max="abc"`      | GetInt("llm", "max", 50)                        | 50 (Default) を返す。パニックしない |

### 2.2 UIStateStore 統合テスト
JSONフォーマットによる構造化データの保存・復元の完全性を検証する。

| ケースID | 目的             | 初期状態     | アクション                                 | 期待される結果                         |
| :------- | :--------------- | :----------- | :----------------------------------------- | :------------------------------------- |
| US-01    | JSONの保存・復元 | 空           | SetJSON("ui", "layout", {w:100}) → GetJSON | {w:100} 構造体が正しく復元される       |
| US-02    | 配列の保存       | 空           | SetJSON("ui", "sizes", [1,2,3]) → GetJSON  | [1,2,3] 配列が正しく復元される         |
| US-03    | 不正なJSON読込   | 文字列 "bad" | GetJSON("ui", "bad_json", &dist)           | JSONパースエラーを返す。パニックしない |

### 2.3 SecretStore 統合テスト
機密情報の分離と取得を検証する。

| ケースID | 目的            | 初期状態           | アクション                             | 期待される結果                          |
| :------- | :-------------- | :----------------- | :------------------------------------- | :-------------------------------------- |
| SS-01    | APIキー保存取得 | 空                 | Set("gemini", "api_key", "sec1") → Get | "sec1" を返す                           |
| SS-02    | キー一覧取得    | `k1="a"`, `k2="b"` | ListSecretKeys("gemini")               | `["k1", "k2"]` を返す（値は含まれない） |

### 2.4 Watch (変更通知) の振る舞い
リアクティブな変更通知がチャネルやコールバックで正しくルーティングされるかを検証する。

| ケースID | 目的         | 初期状態     | アクション                | 期待される結果                    |
| :------- | :----------- | :----------- | :------------------------ | :-------------------------------- |
| WA-01    | 通知の受信   | "ui" をWatch | "ui" 名前空間へSet()実行  | 通知を受け取る（Timeoutしない）   |
| WA-02    | 無関係な通知 | "ui" をWatch | "llm" 名前空間へSet()実行 | 通知を受け取らない（Timeoutする） |

### 2.5 ライフサイクル・同時実行性
スライス初期化時のマイグレーションと、Go特有の並行処理耐性を検証する。

| ケースID | 目的             | 初期状態         | アクション                       | 期待される結果                                 |
| :------- | :--------------- | :--------------- | :------------------------------- | :--------------------------------------------- |
| MG-01    | 新規DB構築       | 空 (DB無し)      | Migrate() 実行                   | 3テーブルの作成、schema_version生成            |
| MG-02    | マイグレスキップ | 最新スキーマ対象 | Migrate() 実行                   | エラー無し、DB変更なし                         |
| CON-01   | 並行書き込み     | 空               | 100 GoroutineでSet/Getを並行連打 | データ競合(race)なし、不整合・デッドロックなし |

---

## 3. 構造化ログとデバッグフロー (Log-based Debugging)

本スライスで不具合が発生した場合やテストが失敗した場合は、**ステップ実行やユニットテストの追加による原因追及を行わず、実行生成物である構造化ログを用いたAIデバッグ** を徹底する。

### 3.1 テスト基盤でのログ準備
テストコードから Contract メソッドを呼び出す際は、必ず `Run` を用いてサブテスト（Table-Drivenの各ケース）ごとに一意の TraceID を持つ `context.Context` を生成して引き回す。

```go
// パラメタライズドテストのループ内例
for _, tc := range testCases {
    t.Run(tc.Name, func(t *testing.T) {
        // AIデバッグ時の追跡を容易にするためのTraceID生成
        ctx, span := tracer.Start(context.Background(), "TestCase_"+tc.ID)
        defer span.End()

        // Contractの呼び出し（裏でslogのEntry/Exitがファイルに出力される）
        err := store.Set(ctx, tc.Namespace, tc.Key, tc.Value)
        // ... 検証処理 ...
    })
}
```

テスト実行基盤として設定ファイルまたはテストラッパーを構成し、出力を `logs/test_YYMMDD_ConfigStore.jsonl` のようなファイルへ JSON 形式で永続化しておくこと。

### 3.2 AI専用デバッグプロンプト
テスト失敗時や、Pipeline からの予期せぬ挙動が検知された場合、以下の定型プロンプトと生成されたログファイルを生成AI（アシスタント）に渡し、インターフェースに基づく修正を指示する。

**デバッグ時AI投入定型プロンプト**:
```text
以下は ConfigStoreSlice の実行ログファイル（logs/test_XXXX_ConfigStore.jsonl）の内容である。
仕様書（openspec/specs/ConfigStoreSlice/spec.md および テスト仕様書）の期待動作と比較し、乖離がある箇所を特定して修正コードを生成せよ。

TraceID を手掛かりに、特定のユースケースにおける Entry/Exit ログの args (引数) および result (戻り値) の変遷に着目すること。

--- 実行ログ ---
{ログファイルの内容をペースト、またはログファイル自体を参照させる}

--- 期待される仕様・テストケース ---
{失敗したテストケース（例: CS-04）、または仕様書の該当する章段落}
```
