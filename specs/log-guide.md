# **AI解析に最適化されたログ設計ガイド**

AI（LLMやログ分析AI）にシステムの問題をトレースさせるためには、ログが「自然言語の文章」ではなく、「構造化されたメタデータの集合（JSON等）」であることが重要です。AIはこれらのキーをフィルタ条件として使い、点と点を繋いでいきます。

## **第1部：ログを取得すべき重要なイベントと要素**

「何が起きたか」だけでなく「なぜ起きたか」をAIやエンジニアが追跡できるよう、以下のポイントでログを取得します。

### **1\. 外部システムとの境界（I/O）**

システムのボトルネックや障害の起因になりやすい箇所です。

* **データベース（SQL）:** 実行SQL（マスキング済）、バインドパラメータ、実行時間、フェッチ/影響行数。  
* **外部API・マイクロサービス通信:** リクエスト先URL、HTTPメソッド、ステータスコード、レスポンスタイム。  
* **非同期通信:** メッセージキューの送受信（トピック名、メッセージID）。

### **2\. 重要な条件分岐の「決定理由」**

複雑なビジネスロジックにおいて、なぜそのルートを通ったのかを記録します。

* **記録内容:** 評価された変数の値、分岐の理由（例: "User is not admin, redirecting to home" ではなく {"action": "CheckPermission", "reason": "InsufficientRole", "role": "Guest"}）。

### **3\. ドメインイベントと状態変化（State Change）**

データやエンティティのライフサイクルが変わったタイミングです。

* **記録内容:** ステータスの遷移（PENDING \-\> COMPLETED）、状態変化の前後の値（JSON Diff等）、イベント名（例: OrderShipped）。

### **4\. 異常系・バリデーションエラー**

システムエラー（500系）だけでなく、クライアントエラー（400系）の理由も重要です。

* **記録内容:** 弾かれた理由、不正な入力値のキー（個人情報を除く）、例外のスタックトレース。

### **5\. セキュリティ・監査**

「誰が・いつ・何をしたか」の証跡です。

* **記録内容:** 認証の成功/失敗、権限の昇格、パスワード変更、機密データの参照ログ。

## **第2部：ログ挿入の判断フロー**

すべての処理にログを仕込むとノイズになるため、以下のフローで判断します。  
graph TD  
    A\["処理の開始"\] \--\> B{"外部へのアクセスがあるか？"}  
    B \-- "Yes" \--\> C\["接続先・パラメータを記録 (I/O)"\]  
    B \-- "No" \--\> D{"複雑な分岐・権限チェックか？"}  
    D \-- "Yes" \--\> E\["決定理由・合致した条件を記録"\]  
    D \-- "No" \--\> F{"データの更新・状態変化を伴うか？"}  
    F \-- "Yes" \--\> G\["更新前後の状態を記録"\]  
    F \-- "No" \--\> H{"正常終了・戻り値を記録"}  
    C \--\> D  
    E \--\> F  
    G \--\> H

## **第3部：AI解析のためのメタデータ（キーとフィルタ条件）**

上記のイベントを記録する際、AIが文脈を繋げるために以下のキー（メタデータ）を含めます。

### **1\. トレース・相関関係のキー（AIが文脈を繋ぐための最重要情報）**

* **trace\_id**: リクエストの入り口から出口まで一貫して付与される一意のID。  
* **span\_id / parent\_span\_id**: 処理ブロックごとのID。AIがコールツリーを再構築するために使います。  
* **session\_id / user\_id / tenant\_id**: 影響範囲を特定するためのキー。  
* **correlation\_id**: 非同期処理をまたいで処理を追跡するためのID。

### **2\. 実行環境とバージョンのキー（AIが「環境依存か」を判定）**

* **env**: 動作環境（production, staging, development）。  
* **service\_name**: マイクロサービス名やコンポーネント名。  
* **app\_version / commit\_hash**: デプロイされているバージョン。  
* **host\_name / pod\_name**: 特定のサーバー/コンテナの識別子。

### **3\. 処理のセマンティクス（AIが「何をしているか」を分類）**

* **action / event\_name**: 処理の抽象名（例: UserLogin, PaymentExecute, DBQuery\_SelectUsers）。  
* **resource\_type**: 操作対象のドメイン（例: Order, UserProfile）。  
* **resource\_id**: 操作対象の具体的なID。  
* **status**: 処理結果のカテゴリ（success, failure, pending, skipped）。

### **4\. パフォーマンスとリソースのキー（AIがボトルネックを検知）**

* **duration\_ms**: 処理にかかったミリ秒。  
* **payload\_size\_bytes**: リクエストやレスポンスのデータサイズ。  
* **retry\_count**: リトライを行った回数。

### **5\. エラー解決のための詳細情報（AIが原因を特定）**

* **error\_code**: アプリケーション固有のエラーコード。  
* **exception\_class**: 発生した例外の型。  
* **stack\_trace**: 生のスタックトレース。  
* **state\_before / state\_after**: 更新前と更新後のデータ構造。

## **第4部：AIが問題を特定する際の推論フロー**

AI（またはログ分析基盤）は、上記の属性を組み合わせて以下のようなフローでトラブルシューティングを行います。  
graph TD  
    A\["アラート発生 (Error Rate上昇など)"\] \--\> B{"共通の属性はあるか？"}  
    B \-- "Yes" \--\> C\["特定の app\_version や host\_name に偏りがないか分析"\]  
    B \-- "No" \--\> D{"代表的な trace\_id を抽出"}  
    C \--\> D  
    D \--\> E\["対象 trace\_id の全ログを時系列で取得"\]  
    E \--\> F{"duration\_ms の異常値や exception\_class を検索"}  
    F \--\> G\["ボトルネックとなった span\_id を特定"\]  
    G \--\> H\["state\_before/after や引数から根本原因を提示"\]