package summary

import (
	"database/sql"
	"testing"

	"github.com/ishibata91/ai-translation-engine-2/pkg/infrastructure/llm_client"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	_ "modernc.org/sqlite"
)

func TestSummaryGenerator_Slice(t *testing.T) {
	// 1. Setup in-memory SQLite
	db, err := sql.Open("sqlite", ":memory:")
	require.NoError(t, err)
	defer db.Close()

	ctx := t.Context()
	store := NewSummaryStore(db)
	err = store.Init(ctx)
	require.NoError(t, err)

	cfg := SummaryConfig{Concurrency: 4}
	gen := NewSummaryGenerator(store, cfg)

	t.Run("ProposeJobs - Dialogue Cache MISS", func(t *testing.T) {
		input := SummaryInput{
			DialogueItems: []DialogueItem{
				{
					GroupID: "DLG_001",
					Lines:   []string{"Hello", "How are you?"},
				},
			},
		}

		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		assert.Len(t, output.Jobs, 1)
		assert.Len(t, output.PreCalculatedResults, 0)
		assert.Equal(t, "DLG_001", output.Jobs[0].Metadata["record_id"])
	})

	t.Run("SaveResults and ProposeJobs - Dialogue Cache HIT", func(t *testing.T) {
		// Mock LLM Response
		responses := []llm_client.Response{
			{
				Success: true,
				Content: "A friendly greeting.",
				Metadata: map[string]interface{}{
					"record_id":    "DLG_001",
					"summary_type": TypeDialogue,
					"cache_key":    "DLG_001|e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", // Dummy or real
					"input_hash":   "e3b0c442...",
					"line_count":   2,
				},
			},
		}
		// First, we need to know the REAL cache key generated by the hasher
		hasher := &CacheKeyHasher{}
		cacheKey, inputHash := hasher.BuildCacheKey("DLG_001", []string{"Hello", "How are you?"})
		responses[0].Metadata["cache_key"] = cacheKey
		responses[0].Metadata["input_hash"] = inputHash

		err := gen.SaveResults(ctx, responses)
		require.NoError(t, err)

		// Now propose again with same input
		input := SummaryInput{
			DialogueItems: []DialogueItem{
				{
					GroupID: "DLG_001",
					Lines:   []string{"Hello", "How are you?"},
				},
			},
		}
		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		assert.Len(t, output.Jobs, 0)
		assert.Len(t, output.PreCalculatedResults, 1)
		assert.Equal(t, "A friendly greeting.", output.PreCalculatedResults[0].SummaryText)
		assert.True(t, output.PreCalculatedResults[0].CacheHit)
	})

	t.Run("ProposeJobs - Quest Cumulative Processing", func(t *testing.T) {
		input := SummaryInput{
			QuestItems: []QuestItem{
				{
					QuestID: "QST_001",
					StageTexts: []QuestStage{
						{Index: 10, Text: "Stage 1 content"},
						{Index: 20, Text: "Stage 2 content"},
					},
				},
			},
		}

		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		// Should have 2 jobs (one for each stage)
		assert.Len(t, output.Jobs, 2)

		// Verify cumulative content
		// Job 0 (Stage 10)
		assert.Contains(t, output.Jobs[0].UserPrompt, "Stage 1 content")
		assert.NotContains(t, output.Jobs[0].UserPrompt, "Stage 2 content")

		// Job 1 (Stage 20)
		assert.Contains(t, output.Jobs[1].UserPrompt, "Stage 1 content")
		assert.Contains(t, output.Jobs[1].UserPrompt, "Stage 2 content")
	})

	t.Run("GetSummary - Retrieve persisted result", func(t *testing.T) {
		result, err := gen.GetSummary(ctx, "DLG_001", TypeDialogue)
		require.NoError(t, err)
		assert.NotNil(t, result)
		assert.Equal(t, "A friendly greeting.", result.SummaryText)
	})

	t.Run("Skip empty Dialogue lines", func(t *testing.T) {
		input := SummaryInput{
			DialogueItems: []DialogueItem{
				{GroupID: "EMPTY", Lines: []string{}},
			},
		}
		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		assert.Len(t, output.Jobs, 0)
		assert.Len(t, output.PreCalculatedResults, 0)
	})

	t.Run("Skip empty Quest StageTexts", func(t *testing.T) {
		input := SummaryInput{
			QuestItems: []QuestItem{
				{QuestID: "QST_EMPTY", StageTexts: []QuestStage{}},
			},
		}
		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		assert.Len(t, output.Jobs, 0)
		assert.Len(t, output.PreCalculatedResults, 0)
	})

	t.Run("Skip Quest with only blank stage texts", func(t *testing.T) {
		input := SummaryInput{
			QuestItems: []QuestItem{
				{
					QuestID: "QST_BLANK",
					StageTexts: []QuestStage{
						{Index: 1, Text: "   "},
						{Index: 2, Text: ""},
					},
				},
			},
		}
		output, err := gen.ProposeJobs(ctx, input)
		require.NoError(t, err)
		assert.Len(t, output.Jobs, 0)
		assert.Len(t, output.PreCalculatedResults, 0)
	})
}
